* TODOs

** TODO Mentions of ancient Unices, compilers, etc.

AIX, IRIX, SGI, Apollo, etc.

** TODO Contradicting comments

Like a docstring saying one thing, but a comment suggesting something
otherwise or just expressing confusion.

** TODO Comments signed by important people

RMS, ESR, Stefan, etc.

* Post material [0/53]

** TODO handwrite.el

handwrite.el, RMS, embedded postscript

** TODO HPUX

"Declare here rather than in the function, as in the rest of Emacs,
   to work around an HPUX compiler bug (?)." in term.c

** TODO babyl and hacks

;; This is an odd variable IMO.
;; You might wonder why it is needed, when we could just do:
;; (set (make-local-variable 'enable-local-variables) nil)
;; These two are not precisely the same.
;; Setting this variable does not cause -*- mode settings to be
;; ignored, whereas setting enable-local-variables does.
;; Only three places in Emacs use this variable: tar and arc modes,
;; and rmail.  The first two don't need it.  They already use
;; inhibit-local-variables-regexps, which is probably enough, and
;; could also just set enable-local-variables locally to nil.
;; Them setting it has the side-effect that dir-locals cannot apply to
;; eg tar files (?).  FIXME Is this appropriate?
;; AFAICS, rmail is the only thing that needs this, and the only
;; reason it uses it is for BABYL files (which are obsolete).
;; These contain "-*- rmail -*-" in the first line, which rmail wants
;; to respect, so that find-file on a BABYL file will switch to
;; rmail-mode automatically (this is nice, but hardly essential,
;; since most people are used to explicitly running a command to
;; access their mail; M-x gnus etc).  Rmail files may happen to
;; contain Local Variables sections in messages, which Rmail wants to
;; ignore.  So AFAICS the only reason this variable exists is for a
;; minor convenience feature for handling of an obsolete Rmail file format.

** TODO tromey

tromey on throw-on-input:

  DEFVAR_LISP ("throw-on-input", Vthrow_on_input,
	       doc: /* If non-nil, any keyboard input throws to this symbol.
The value of that variable is passed to `quit-flag' and later causes a
peculiar kind of quitting.  */);
  Vthrow_on_input = Qnil;

** TODO Tramp

tramp-sh.el:

      ;; Return exit status.
      (if (equal ret -1)
	  (keyboard-quit)
	ret))))

** TODO edebug

should be pretty great

** TODO paredit

;;; Please do not try to understand this code unless you have a VERY
;;; good reason to do so.  I gave up trying to figure it out well
;;; enough to explain it, long ago.

credit: https://github.com/HisaoNakai

** TODO maximum string literal length

emacs.c

used to be:

/* C89 needs each string be at most 509 characters, so the usage
   strings below are split to not overflow this limit.  */

is now:

/* C99 needs each string to be at most 4095 characters, and the usage
   strings below are split to not overflow this limit.  */

string splitting is still the same for the approximately 5000
characters which is pretty confusing

** TODO supported platforms

config.in:

- AIX
- Cray-2/Cray-YMP
- Cygwin
- Darwin (aka OS X)
- DG/UX
- Encore UMAX
- HPUX
- IRIX
- MINIX
- MSDOS
- NetBSD
- Solaris
- Tandem NonStop
- Win9x
- Win32
- WinNT

/* Without the following workaround, Emacs runs slowly on OS X 10.8.
   The workaround disables some useful run-time checking, so it
   should be conditional to the platforms with the performance bug.
   Perhaps Apple will fix this some day; also see m4/extern-inline.m4.  */

** TODO Memory Allocation

- DOUG_LEA_MALLOC, GNU_MALLOC, SYSTEM_MALLOC
- http://lwn.net/Articles/636386/

** TODO DOS/V

/* FIXME: I'm not sure the above will run at all on DOS/V.  But let's
   be defensive anyway.  */
if (screen_virtual_segment)
  dosv_refresh_virtual_screen (0, *cols * *rows);

** TODO GOTO cursor

/* Emacs calls cursor-movement functions a lot when it updates the
   display (probably a legacy of old terminals where you cannot
   update a screen line without first moving the cursor there).
   However, cursor movement is expensive on MSDOS (it calls a slow
   BIOS function and requires 2 mode switches), while actual screen
   updates access the video memory directly and don't depend on
   cursor position.  To avoid slowing down the redisplay, we cheat:
   all functions that move the cursor only set internal variables
   which record the cursor position, whereas the cursor is only
   moved to its final position whenever screen update is complete.

   `IT_cmgoto' is called from the keyboard reading loop and when the
   frame update is complete.  This means that we are ready for user
   input, so we update the cursor position to show where the point is,
   and also make the mouse pointer visible.

   Special treatment is required when the cursor is in the echo area,
   to put the cursor at the end of the text displayed there.  */

/* Maybe cursor is invisible, so make it visible.  */
IT_display_cursor (1);

** TODO Vital clues

  /* Don't restore the screen if we are exiting less than 2 seconds
     after startup: we might be crashing, and the screen might show
     some vital clues to what's wrong.  */
  if (clock () - startup_time >= 2*CLOCKS_PER_SEC)
    {
      ScreenClear ();
      if (screen_virtual_segment)
	dosv_refresh_virtual_screen (0, screen_size);

      if (update_row_len > saved_row_len)
	update_row_len = saved_row_len;
      if (current_rows > startup_screen_size_Y)
	current_rows = startup_screen_size_Y;

      if (tty->termscript)
	fprintf (tty->termscript, "<SCREEN RESTORED (dimensions=%dx%d)>\n",
		 update_row_len / 2, current_rows);

      while (current_rows--)
	{
	  dosmemput (saved_row, update_row_len, display_row_start);
	  if (screen_virtual_segment)
	    dosv_refresh_virtual_screen (display_row_start - ScreenPrimary,
					 update_row_len / 2);
	  saved_row         += saved_row_len;
	  display_row_start += to_next_row;
	}
  }

** TODO Busy Bee

        /* We only look at the keyboard Ctrl/Shift/Alt keys when
           Emacs is ready to read a key.  Therefore, if they press
           `Alt-x' when Emacs is busy, by the time we get to
           `dos_get_modifiers', they might have already released the
           Alt key, and Emacs gets just `x', which is BAD.
           However, for keys with the `Map' property set, the ASCII
           code returns zero only if Alt is pressed.  So, when we DON'T
           have to support international_keyboard, we don't have to
           distinguish between the left and  right Alt keys, and we
           can set the META modifier for any keys with the `Map'
           property if they return zero ASCII code (c = 0).  */

** TODO Sound of one clapping hand

  /* We have a situation here.  ScreenUpdate has just restored the
     screen contents as it was before we started drawing this menu.
     That includes any echo area message that could have been
     displayed back then.  (In reality, that echo area message will
     almost always be the ``keystroke echo'' that echoes the sequence
     of menu items chosen by the user.)  However, if the menu had some
     help messages, then displaying those messages caused Emacs to
     forget about the original echo area message.  So when
     ScreenUpdate restored it, it created a discrepancy between the
     actual screen contents and what Emacs internal data structures
     know about it.

     To avoid this conflict, we force Emacs to restore the original
     echo area message as we found it when we entered this function.
     The irony of this is that we then erase the restored message
     right away, so the only purpose of restoring it is so that
     erasing it works correctly...  */

** TODO Down the hall, second-to-last door on the left

/* Simulation of X's menus.  Nothing too fancy here -- just make it work
   for now.

   Actually, I don't know the meaning of all the parameters of the functions
   here -- I only know how they are called by xmenu.c.  I could of course
   grab the nearest Xlib manual (down the hall, second-to-last door on the
   left), but I don't think it's worth the effort.  */

** TODO You're a product of your environment

/* Define a lot of environment variables if not already defined.  Don't
   remove anything unless you know what you're doing -- lots of code will
   break if one or more of these are missing.  */

  /* Note the startup time, so we know not to clear the screen if we
     exit immediately; see IT_reset_terminal_modes.
     (Yes, I know `clock' returns zero the first time it's called, but
     I do this anyway, in case some wiseguy changes that at some point.)  */
  startup_time = clock ();

    /* In some sense all dos users have root privileges, so...  */
  setenv ("USER", "root", 0);
  setenv ("NAME", getenv ("USER"), 0);

  /* Time zone determined from country code.  To make this possible, the
     country code may not span more than one time zone.  In other words,
     in the USA, you lose.  */

** TODO Will the real frame please show up?

xterm.c and x_make_frame_visible

** TODO What's this for?

<forcer> wasamasa: Something for your blog. ert.el:768 talks about
    "work around Emacs's heuristic for detecting errors in the
    debugger". This line of code increments a variable counting
    *nonmacro input events*. If that is not incremented between two
    errors, the debugger won't trigger for the second error. The
    relevant line in eval.c (1724) has this comment: /* RMS: What's
    this for?  */
<wasamasa> forcer: I'll take a look at it
<wasamasa> forcer: thanks for the find!
<forcer> wasamasa: You're welcome.
<wasamasa> forcer: you won't mind if I'll credit you I assume?
<forcer> wasamasa: Nope
<wasamasa> forcer: anything more specific than your github account?
<forcer> wasamasa: You can use that, or www.jorgenschaefer.de, either
    works

<forcer> The only way of getting the backtrace of an error is by
    binding `debugger' to a function that uses `backtrace-frame' to
    get that. And then use `signal' to jump back to the original
    code. But if you do that for two errors in a row, `debugger' is
    not called for the second one unless you (cl-incf
    num-nonmacro-input-events). I just spent a good half an hour on
    that.

** TODO advertising

see display-startup-echo-area-message

** TODO xdg-open

browse-url-can-use-xdg

** TODO bytecomp.el

- ";; We successfully didn't compile this file."

- ; argh unix

- "!! The file uses old-style backquotes !!
This functionality has been obsolete for more than 10 years already
and will be removed soon.  See (elisp)Backquote in the manual."

- byte-compile-fix-header

- ;; Insert semicolons as ballast, so that byte-compile-fix-header
  ;; can delete them so as to keep the buffer positions
  ;; constant for the actual compiled code.

- ;; To avoid consing up monstrously large forms at load time, we split
  ;; the output regularly.

- ;; If things not being bound at all is ok, so must them being
  ;; obsolete.  Note that we add to the existing lists since Tramp
  ;; (ab)uses this feature.

- ;; If foo.el declares `toto' as obsolete, it is likely that foo.el will
  ;; actually use `toto' in order for this obsolete variable to still work
  ;; correctly, so paradoxically, while byte-compiling foo.el, the presence
  ;; of a make-obsolete-variable call for `toto' is an indication that `toto'
  ;; should not trigger obsolete-warnings in foo.el.

- ;; FIXME: we also use this hunk-handler to implement the function's dynamic
  ;; docstring feature.  We could actually implement it more elegantly in
  ;; byte-compile-lambda so it applies to all lambdas, but the problem is that
  ;; the resulting .elc format will not be recognized by make-docfile, so
  ;; either we stop using DOC for the docstrings of preloaded elc files (at the
  ;; cost of around 24KB on 32bit hosts, double on 64bit hosts) or we need to
  ;; build DOC in a more clever way (e.g. handle anonymous elements).

- ;; Don't reload the source version of the files below
  ;; because that causes subsequent byte-compilation to
  ;; be a lot slower and need a higher max-lisp-eval-depth,
  ;; so it can cause recompilation to fail.

- ;; To avoid "lisp nesting exceeds max-lisp-eval-depth" when bytecomp compiles
  ;; itself, compile some of its most used recursive functions (at load time).

- 	(if t				;(not (zerop n))

** TODO documentation

explain how it works, that byte-compiled stuff can or can not have
docstrings and laugh about the "goto oops"

** TODO A Piece of Advice

- advice.el redefines functions and macros and does a lot
- it has 1500 lines of usage information, probably more than the manual
- ad-substitute-tree (yay for dynamic scoping)
- rplaca (only usage in 24.4 sources), rplacd (used here and in byte-opt.el)
- ad-recover-normality (real emergencies please!)

- nadvice.el is brutally short
- it's using bytecode hackery (looks up the correct byte-code,
  generates something runnable from it and replaces the function
  definition with it while retaining everything else)
- ;; There's no direct access to the C code (in call-interactively) that
  ;; processes those specs, but that shouldn't stop us, should it?
- advice--called-interactively-skip and the frames

** TODO byte-opt.el

- byte-optimize-approx-equal tells me that 99 and 100 are close enough
- disassemble-offset (perhaps its docstring means that there is no
  proper bytecode disassembly API yet)

** TODO backslashitis

see ref-tex.el and its seventeen backslashes and
http://lists.gnu.org/archive/html/emacs-devel/2014-07/msg00313.html
and
http://lists.gnu.org/archive/html/emacs-devel/2012-08/msg00094.html

** TODO Enter the void

- backtraces frequently contain bytecode (because they use
  `symbol-function` to obtain the definition?)
- NULs break copy-paste for me
- NULs break M-x report-emacs-bug or at least worsen the experience
  (by asking for encoding and such)

** TODO eldoc

mutates constants, claims to use an obarray, deletes messages

** TODO reftex-sel

callbacks??

** TODO isearch

it's using the fucking echo area

** TODO form-feed

- cursor kicking and delete-trailing-whitespace (step the function and
  look at cursor kicking)
- fontification taking ages (management of extra properties? emacs-git
  and font-lock-flush?)

** TODO term.el

;; This simple facility just sends strings to the inferior process and pops
;; up a window for the process buffer so you can see what the process
;; responds with.  We don't do anything fancy like try to intercept what the
;; process responds with and put it in a pop-up window or on the message
;; line.  We just display the buffer.  Low tech.  Simple.  Works good.

;; Try to position the proc window so you can see the answer.
;; This is bogus code.  If you delete the (sit-for 0), it breaks.
;; I don't know why.  Wizards invited to improve it.

;; I am somewhat divided on this string-default feature.  It seems
;; to violate the principle-of-least-astonishment, in that it makes
;; the default harder to predict, so you actually have to look and see
;; what the default really is before choosing it.  This can trip you up.
;; On the other hand, it can be useful, I guess.  I would appreciate feedback
;; on this.
;;     -Olin

;; This is pretty stupid about strings.  It decides we're in a string
;; if there's a quote on both sides of point on the current line.

;;Function that handles term messages: code by rms (and you can see the
;;difference ;-) -mm

term-read-noecho

;; This seems a bit complex.  We look for references such as !!, !-num,
;; !foo, !?foo, !{bar}, !?{bar}, ^oh, ^my^, ^god^it, ^never^ends^.

term-regexp-arg

smalltalk on a risc

;;This is guaranteed to wait long enough
;;but has bad results if the term does not prompt at all
;;	     (while (= size (buffer-size))
;;	       (sleep-for 1))
;;I hope 1 second is enough!

; This argument to set-process-filter disables reading from the process,
; assuming this is Emacs 19.20 or newer.

** TODO ediff-make-bullet-proof-overlay

** TODO DEAFUN

/* PLEASE DO NOT DELETE THIS COMMENTED-OUT VERSION!
   This is the old version of expand-file-name, before it was thoroughly
   rewritten for Emacs 10.31.  We leave this version here commented-out,
   because the code is very complex and likely to have subtle bugs.  If
   bugs _are_ found, it might be of interest to look at the old code and
   see what did it do in the relevant situation.

   Don't remove this code: it's true that it will be accessible
   from the repository, but a few years from deletion, people will
   forget it is there.  */

** TODO DEFUN and doc-snarfing

why? to make it feel as lisp-like as possible while keeping the
possibility of having the compiler barf at you

** TODO url-gc-dead-buffers

** TODO firestarter

buffer-list-update-hook being unusable is a major wtf, couple it with
intro, rant about buffers being poor values and show a bit of
benchmarking (with circe)

#+BEGIN_SRC emacs-lisp
(with-timer
  (dotimes (_ 100000)
    (with-temp-buffer
      (insert "FUNBEACHBALL")
      ;; 5.609s with let-bound `buffer-list-update-hook', 57.657s without
      (translate-region (point-min) (point-max) irc-isupport--ascii-table))))

(with-timer
  (dotimes (_ 100000)
    (let ((string "FUNBEACHBALL"))
      ;; 1.095s, algorithm lifted from `irc-isupport--ascii-table'
      (dotimes (index (length string))
        (let ((char (aref string index)))
          (when (and (<= ?A char) (<= char ?Z))
            (aset string index (+ char (- ?a ?A)))))))))
#+END_SRC

** TODO ESR and mail address parsing

mail/mail-extr.el:mail-extract-address-components

; HAVE I NO SHAME??

** TODO judge, condemn and redeem

w32term.c:

/* The following three hooks are used when we're doing a thorough
   redisplay of the frame.  We don't explicitly know which scroll bars
   are going to be deleted, because keeping track of when windows go
   away is a real pain - "Can you say set-window-configuration, boys
   and girls?"  Instead, we just assert at the beginning of redisplay
   that *all* scroll bars are to be removed, and then save a scroll bar
   from the fiery pit when we actually redisplay its window.  */

** TODO eventp

thanks to wgreenhouse!

** TODO recentf

installing a package makes its files end up in recentf

<jlf> [01:27:54] and wow is recentf.el ever a fucking horrorshow, see
e.g. the recentf-digit-shortcut-command-name defsubst and the
surrounding perversions

** TODO fonts

figure out why emacs cannot just use the pile of poo

uniscribe on windows, core text on os x, fontconfig/pango on linux

** TODO SIGSAUER

http://ajaxxx.livejournal.com/62378.html

** TODO seriously confusing

xdisp.c

/* Temporarily disable garbage collections while displaying the echo
   area.  This is done because a GC can print a message itself.
   That message would modify the echo area buffer's contents while a
   redisplay of the buffer is going on, and seriously confuse
   redisplay.  */

** TODO evil menu item hack

explain it and show the parts of emacs that make it work

** TODO deactivate-mark hacks

this would be a code-less post refering to eyebrowse and magit and debbugs

** TODO htmlize

;; the remainder of this list really belongs in a museum

** TODO url-domsuf

over 100kb for a rarely used domain alist

benchmark how a hash table solution would look like

** TODO match-string

it's elisp...

** TODO revert-buffer

  ;; I admit it's odd to reverse the sense of the prefix argument, but
  ;; there is a lot of code out there which assumes that the first
  ;; argument should be t to avoid consulting the auto-save file, and
  ;; there's no straightforward way to encourage authors to notice a
  ;; reversal of the argument sense.  So I'm just changing the user
  ;; interface, but leaving the programmatic interface the same.

** TODO Accidental Algorithmic Annihilation

Thanks to Fuco for wondering why imenu went slower in Emacs 24.5

imenu.el
;; Go backwards for convenience of adding items in order.

** TODO insert-file-contents-literally

